"use strict";(self.webpackChunktaichi_js_com=self.webpackChunktaichi_js_com||[]).push([[164],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=p(n),u=i,h=m["".concat(l,".").concat(u)]||m[u]||d[u]||r;return n?a.createElement(h,s(s({ref:t},c),{},{components:n})):a.createElement(h,s({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[m]="string"==typeof e?e:i,s[1]=o;for(var p=2;p<r;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6677:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:3,title:"Type System"},s=void 0,o={unversionedId:"docs/basics/type-system",id:"docs/basics/type-system",title:"Type System",description:'In order for it to be compiled into WebGPU shaders, the Javascript function passed into ti.kernel() needs to obey certain rules that are not common to Javascript code. Most importantly, in normal Javascript-scope code, types of variables are not fixed and may change at runtime. This is different from kernel-scope code, where variables are "statically-typed". This means that types are fixed and determined at compile-time. When writing kernel code, it\'s useful to have a mental model of the type system in place, which this document will describe.',source:"@site/docs/docs/1-basics/3-type-system.md",sourceDirName:"docs/1-basics",slug:"/docs/basics/type-system",permalink:"/docs/docs/basics/type-system",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/docs/1-basics/3-type-system.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Type System"},sidebar:"tutorialSidebar",previous:{title:"Kernels",permalink:"/docs/docs/basics/kernels"},next:{title:"Fields",permalink:"/docs/docs/basics/fields"}},l={},p=[{value:"Primitives",id:"primitives",level:2},{value:"Vectors",id:"vectors",level:2},{value:"Matrices",id:"matrices",level:2},{value:"Structs",id:"structs",level:2}],c={toc:p},m="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In order for it to be compiled into WebGPU shaders, the Javascript function passed into ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.kernel()"),' needs to obey certain rules that are not common to Javascript code. Most importantly, in normal Javascript-scope code, types of variables are not fixed and may change at runtime. This is different from kernel-scope code, where variables are "statically-typed". This means that types are fixed and determined at compile-time. When writing kernel code, it\'s useful to have a mental model of the type system in place, which this document will describe. '),(0,i.kt)("p",null,'We will begin with four of the most simple and commonly used data types: primitives, vectors, matrices, and structs. We will discuss how to declare variables of these types, and common operations on them. We will also show how to declare these types as arguments to kernels. Beyond these simple types, "variables" in kernels can also refer to data containers (i.e. ',(0,i.kt)("a",{parentName:"p",href:"https://taichi-js.com/docs/docs/basics/fields"},"fields")," and ",(0,i.kt)("a",{parentName:"p",href:"https://taichi-js.com/docs/docs/rendering/textures"},"textures"),") or ",(0,i.kt)("a",{parentName:"p",href:"https://taichi-js.com/docs/docs/advanced/functions-and-lambdas"},"lambdas/functions"),", which will be discussed in separate doc pages. "),(0,i.kt)("h2",{id:"primitives"},"Primitives"),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js"),", there are only two primitive types at the moment: ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"f32"),". The compiler determines the type of a variable depending on the expression of its initializer:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let i = 1   // i32\nlet f = 1.0 // f32 \n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"i32")," values can be casted to ",(0,i.kt)("inlineCode",{parentName:"p"},"f32")," via ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.f32(..)"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"f32")," values can be casted to ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," via ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.i32(..)"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let i = ti.i32(4.2) // i32\nlet f = ti.f32(42)  // f32\n")),(0,i.kt)("p",null,"when a valid operation is performed between an ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"f32"),", the integer is automatically promoted:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let i = ti.i32(4.2) // i32\nlet f = ti.f32(42)  // f32\nlet f2 = f + i      // f32\n")),(0,i.kt)("p",null,"Due to Javascript's lack of type annotations, kernel argument types in ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js")," are specified via an extra argument to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.kernel()")," call. The following example shows how to pass an ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"f32")," to a kernel, which returns their sum:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let k = ti.kernel(\n    { i: ti.i32, f: ti.f32 },\n    (i, f) => {\n        return i + f\n    }\n)\nconsole.log(await k(1, 2.5)) // prints 3.5\n")),(0,i.kt)("p",null,"If you don't specify the arguments, then ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js")," will assume they are ",(0,i.kt)("inlineCode",{parentName:"p"},"f32"),"s by default:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let k = ti.kernel(\n    (f1, f2) => {\n        return f1 + f2\n    }\n)\nconsole.log(await k(1.5, 2.5)) // prints 4.0\n")),(0,i.kt)("h2",{id:"vectors"},"Vectors"),(0,i.kt)("p",null,"Vectors are fixed-size tuples of primitives. In ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js"),", tuples are declared via the Javascript array notation ",(0,i.kt)("inlineCode",{parentName:"p"},"[...]"),". For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let vi = [0, 1, 2]\nlet vf = [0.0, 1.0, 2.0, 3.0]\n")),(0,i.kt)("p",null,"Individual components of of vectors can be acessed by indexing with an integer",(0,i.kt)("inlineCode",{parentName:"p"},"v[i]"),". Notice that, at the moment, indices used to access vectors must be compile-time constant expressions. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let v = [0.0, 1.0, 2.0, 3.0]\nlet f = v[0] // 0.0\nf = v[1] // 1.0\n")),(0,i.kt)("p",null,"Alternatively, for accessing the first 4 elements, you also write ",(0,i.kt)("inlineCode",{parentName:"p"},".x/.y/.z/.w")," or ",(0,i.kt)("inlineCode",{parentName:"p"},".r/.g/.b/.a"),". This is handy if your vector represents a 3D point/direction, or a color:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let v = [0.0, 1.0, 2.0, 3.0]\nlet f = v.x // 0.0\nf = v.g // 1.0\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js"),' also supports "swizzling":'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let v = [0, 1, 2, 3]\nlet v1 = v.xyz // [0, 1, 2]\nlet v2 = v.bgr // [2, 1, 0]\n")),(0,i.kt)("p",null,"Vectors of the same type can have arithmetic operations among each other, where arithmetics are applied component wise. For example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let v = [1.0, 2.0] + [3.0, 4.0] // v = [4.0, 6.0]\n")),(0,i.kt)("p",null,"Vectors can also have arithmetic operations with scalars, where the scalar is broadcasted:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let v = [1.0, 2.0] * 2.0 // v = [2.0, 4.0]\n")),(0,i.kt)("p",null,"Beyond arithmetics, ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js")," contains many built-in mathematical operations which you can make use of. These are listed ",(0,i.kt)("a",{parentName:"p",href:"https://taichi-js.com/docs/docs/basics/builtin-functions"},"here"),"."),(0,i.kt)("p",null,"For passing vectors into kernels as arguments, declare the argument as ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.types.vector( <primitive type name>, <component count> )"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let length = ti.kernel(\n    {v: ti.types.vector(ti.f32, 2)},\n    (v) => {\n        return ti.sqrt(v.x * v.x + v.y * v.y)\n    }\n)\nconsole.log(await length([3, 4])) // prints 5\n")),(0,i.kt)("h2",{id:"matrices"},"Matrices"),(0,i.kt)("p",null,"Matrices are fixed size of tuples of vectors of the same size. In ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js"),", matrices are declared via 2D arrays of primitives. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let identity = [[1.0, 0.0], \n                [0.0, 1.0]]\n")),(0,i.kt)("p",null,"Matrices in ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js")," are row-major. This means that each vector in the initializer is a row-vector, and when accessing matrices using an integer index ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),"th row will be returned:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let m = [[1.0, 2.0], [3.0, 4.0]]\nlet v = m[0] // [1.0, 2.0]\n")),(0,i.kt)("p",null,"As with vectors, arithmetic operations among matrices are done component-wise, and primitives can be broadcased to operate with matrices:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let m1 = [[1.0, 2.0], [3.0, 4.0]] + [[4.0, 3.0], [2.0, 1.0]] // [[5.0, 5.0], [5.0, 5.0]]\nlet m2 = [[1.0, 2.0], [3.0, 4.0]] * 2.0 // [[2.0, 4.0], [6.0, 8.0]]\n")),(0,i.kt)("p",null,"Common operations among matrices and vectors are available via built-in functions. For example, for matrix-vector multiplication, you can write it using the ",(0,i.kt)("inlineCode",{parentName:"p"},"matmul")," built-in. There are two syntaxes for this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let m = [[1.0, 2.0], [3.0, 4.0]]\nlet v = m[0] // [1.0, 2.0]\n\nlet mv1 = m.matmul(v)\nlet mv2 = ti.matmul(m, v)\n// mv1 == mv2 == [5, 11]\n")),(0,i.kt)("p",null,"For passing vectors into kernels as arguments, declare the argument as ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.types.matrix( <primitive type name>, <row count>, <column count> )"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let trace = ti.kernel(\n    {m: ti.types.matrix(ti.f32, 2, 2)},\n    (m) => {\n        return m[0][0] + m[1][1];\n    }\n)\nconsole.log(await trace([[1.0, 2.0], [3.0, 4.0]])) // prints 5\n")),(0,i.kt)("h2",{id:"structs"},"Structs"),(0,i.kt)("p",null,"Structs are collections of values with names. These are described with the Javascript object notation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let particle = {\n    index: 0,\n    position: [1.0, 2.0, 3.0],\n    velocity: [4.0, 5.0, 6.0]\n}\n")),(0,i.kt)("p",null,"As with Javascript objects, elements of structs can be accessed via the dot notation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let o = {i:0, v: [1.0, 2.0]};\nlet v = o.v; // [1.0, 2.0];\n")),(0,i.kt)("p",null,"For passing vectors into kernels as arguments, declare the argument as ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.types.struct({ <element name> : <element type> ... })"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let particleType = ti.types.struct({\n    position: ti.types.vector(ti.f32, 3),\n    velocity: ti.types.vector(ti.f32, 3),\n})\nlet predictNewPosition = ti.kernel(\n    {p: particleType, time: ti.f32},\n    (p, time) => {\n        return p.position + time * p.velocity;\n    }\n)\nconsole.log(await predictNewPosition({\n    position: [0, 0, 0],\n    velocity: [1, 1, 1]\n}, 2)) \n// prints [2, 2, 2]\n")))}d.isMDXComponent=!0}}]);