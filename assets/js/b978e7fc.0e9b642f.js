"use strict";(self.webpackChunktaichi_js_com=self.webpackChunktaichi_js_com||[]).push([[2230],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),u=r,h=d["".concat(l,".").concat(u)]||d[u]||m[u]||a;return n?i.createElement(h,o(o({ref:t},p),{},{components:n})):i.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<a;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4189:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var i=n(7462),r=(n(7294),n(3905));const a={sidebar_position:1,title:"Getting Started"},o=void 0,s={unversionedId:"docs/basics/getting-started",id:"docs/basics/getting-started",title:"Getting Started",description:"taichi.js is a Javascript framework which translates JS code into WebGPU compute and/or render pipelines. With taichi.js, the programmer can write WebGPU programs without having to deal with WebGPU's API or shading language. It offers a way to rapidly prototype WebGPU programs, for both parallel computation and rendering purposes. It is inspire by and named after the taichi Python library, from which it also inherits many API concepts and design principles.",source:"@site/docs/docs/1-basics/1-getting-started.md",sourceDirName:"docs/1-basics",slug:"/docs/basics/getting-started",permalink:"/docs/docs/basics/getting-started",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/docs/1-basics/1-getting-started.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Getting Started"},sidebar:"tutorialSidebar",previous:{title:"Painless WebGPU Programming",permalink:"/docs/articles/painless-webgpu-programming"},next:{title:"Fields",permalink:"/docs/docs/basics/fields"}},l={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Trying <code>taichi.js</code>",id:"trying-taichijs",level:2},{value:"Npm",id:"npm",level:2},{value:"Example",id:"example",level:2}],p={toc:c},d="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js")," is a Javascript framework which translates JS code into WebGPU compute and/or render pipelines. With ",(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js"),", the programmer can write WebGPU programs without having to deal with WebGPU's API or shading language. It offers a way to rapidly prototype WebGPU programs, for both parallel computation and rendering purposes. It is inspire by and named after the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/taichi-dev/taichi"},(0,r.kt)("inlineCode",{parentName:"a"},"taichi"))," Python library, from which it also inherits many API concepts and design principles."),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js")," depends on WebGPU, which is avaialable since Chrome v113."),(0,r.kt)("h2",{id:"trying-taichijs"},"Trying ",(0,r.kt)("inlineCode",{parentName:"h2"},"taichi.js")),(0,r.kt)("p",null,"The quickest way to play with ",(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js")," is to access the ",(0,r.kt)("a",{parentName:"p",href:"https://taichi-js.com/playground"},"Playground page"),". You can edit, build, and run ",(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js"),' programs directly in this playground. You can also click the "Edit on Stackblitz" button, which will take you to a StackBlitz project that can be downloaded, so you can work on it locally.'),(0,r.kt)("h2",{id:"npm"},"Npm"),(0,r.kt)("p",null,"You can also add ",(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js")," to your node project by running"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npm install taichi.js --save\n")),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,'The following code shows a WebGPU "Game of Life" program written in ',(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js"),". This example contains 3 WebGPU compute pipelines and 1 WebGPU render pipeline, all of which are implemented in ",(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js")," with basic typescript syntax. This demo is explained in details in ",(0,r.kt)("a",{parentName:"p",href:"https://taichi-js.com/docs/articles/painless-webgpu-programming"},"this article"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import * as ti from \"taichi.js\"\n\nlet main = async () => {\n    await ti.init();\n\n    let N = 128;\n\n    let liveness = ti.field(ti.i32, [N, N])\n    let numNeighbors = ti.field(ti.i32, [N, N])\n\n    ti.addToKernelScope({ N, liveness, numNeighbors });\n\n    let init = ti.kernel(() => {\n        for (let I of ti.ndrange(N, N)) {\n            liveness[I] = 0\n            let f = ti.random()\n            if (f < 0.2) {\n                liveness[I] = 1\n            }\n        }\n    })\n    await init()\n\n    let countNeighbors = ti.kernel(() => {\n        for (let I of ti.ndrange(N, N)) {\n            let neighbors = 0\n            for (let delta of ti.ndrange(3, 3)) {\n                let J = (I + delta - 1) % N\n                if ((J.x != I.x || J.y != I.y) && liveness[J] == 1) {\n                    neighbors = neighbors + 1;\n                }\n            }\n            numNeighbors[I] = neighbors\n        }\n    });\n    let updateLiveness = ti.kernel(() => {\n        for (let I of ti.ndrange(N, N)) {\n            let neighbors = numNeighbors[I]\n            if (liveness[I] == 1) {\n                if (neighbors < 2 || neighbors > 3) {\n                    liveness[I] = 0;\n                }\n            }\n            else {\n                if (neighbors == 3) {\n                    liveness[I] = 1;\n                }\n            }\n        }\n    })\n\n    let htmlCanvas = document.getElementById('result_canvas');\n    htmlCanvas.width = 512;\n    htmlCanvas.height = 512;\n    let renderTarget = ti.canvasTexture(htmlCanvas);\n\n    let vertices = ti.field(ti.types.vector(ti.f32, 2), [6]);\n    await vertices.fromArray([\n        [-1, -1],\n        [1, -1],\n        [-1, 1],\n        [1, -1],\n        [1, 1],\n        [-1, 1],\n    ]);\n\n    ti.addToKernelScope({ vertices, renderTarget });\n\n    let render = ti.kernel(() => {\n        ti.clearColor(renderTarget, [0.0, 0.0, 0.0, 1.0]);\n        for (let v of ti.inputVertices(vertices)) {\n            ti.outputPosition([v.x, v.y, 0.0, 1.0]);\n            ti.outputVertex(v);\n        }\n        for (let f of ti.inputFragments()) {\n            let coord = (f + 1) / 2.0;\n            let cellIndex = ti.i32(coord * (liveness.dimensions - 1));\n            let live = ti.f32(liveness[cellIndex]);\n            ti.outputColor(renderTarget, [live, live, live, 1.0]);\n        }\n    });\n\n    async function frame() {\n        countNeighbors()\n        updateLiveness()\n        await render();\n        requestAnimationFrame(frame);\n    }\n    await frame();\n};\n\nmain()\n")))}m.isMDXComponent=!0}}]);