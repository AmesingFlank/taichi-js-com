"use strict";(self.webpackChunktaichi_js_com=self.webpackChunktaichi_js_com||[]).push([[164],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>f});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(a),u=i,f=d["".concat(l,".").concat(u)]||d[u]||m[u]||r;return a?n.createElement(f,s(s({ref:t},p),{},{components:a})):n.createElement(f,s({ref:t},p))}));function f(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:i,s[1]=o;for(var c=2;c<r;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},6677:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var n=a(7462),i=(a(7294),a(3905));const r={sidebar_position:3,title:"Type System"},s=void 0,o={unversionedId:"docs/basics/type-system",id:"docs/basics/type-system",title:"Type System",description:'In order for it to be compiled into WebGPU shaders, the Javascript function passed into ti.kernel() needs to obey certain rules that are not common to Javascript code. Most importantly, in normal Javascript-scope code, types of variables are not fixed and may change at runtime. This is different from kernel-scope code, where variables are "statically-typed". This means that types are fixed and determined at compile-time. When writing kernel code, it\'s useful to have a mental model of the type system in place, which this document will describe.',source:"@site/docs/docs/1-basics/3-type-system.md",sourceDirName:"docs/1-basics",slug:"/docs/basics/type-system",permalink:"/docs/docs/basics/type-system",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/docs/1-basics/3-type-system.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Type System"},sidebar:"tutorialSidebar",previous:{title:"Kernels",permalink:"/docs/docs/basics/kernels"},next:{title:"Fields",permalink:"/docs/docs/basics/fields"}},l={},c=[{value:"Primitives",id:"primitives",level:2},{value:"Vectors",id:"vectors",level:2},{value:"Matrices",id:"matrices",level:2},{value:"Structs",id:"structs",level:2}],p={toc:c},d="wrapper";function m(e){let{components:t,...a}=e;return(0,i.kt)(d,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In order for it to be compiled into WebGPU shaders, the Javascript function passed into ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.kernel()"),' needs to obey certain rules that are not common to Javascript code. Most importantly, in normal Javascript-scope code, types of variables are not fixed and may change at runtime. This is different from kernel-scope code, where variables are "statically-typed". This means that types are fixed and determined at compile-time. When writing kernel code, it\'s useful to have a mental model of the type system in place, which this document will describe. '),(0,i.kt)("p",null,'We will begin with four of the most simple and commonly used data types: primitives, vectors, matrices, and structs. We will discuss how to declare variables of these types, and common operations on them. We will also show how to declare these types as arguments to kernels. Beyond these simple types, "variables" in kernels can also refer to data containers (i.e. ',(0,i.kt)("a",{parentName:"p",href:"https://taichi-js.com/docs/docs/basics/fields"},"fields")," and ",(0,i.kt)("a",{parentName:"p",href:"https://taichi-js.com/docs/docs/rendering/textures"},"textures"),") or ",(0,i.kt)("a",{parentName:"p",href:"https://taichi-js.com/docs/docs/advanced/functions-and-lambdas"},"lambdas/functions"),", which will be discussed in separate doc pages. "),(0,i.kt)("h2",{id:"primitives"},"Primitives"),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js"),", there are only two primitive types at the moment: ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"f32"),". The compiler determines the type of a variable depending on the expression of its initializer:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let i = 1   // i32\nlet f = 1.0 // f32 \n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"i32")," values can be casted to ",(0,i.kt)("inlineCode",{parentName:"p"},"f32")," via ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.f32(..)"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"f32")," values can be casted to ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," via ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.i32(..)"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let i = ti.i32(4.2) // i32\nlet f = ti.f32(42)  // f32\n")),(0,i.kt)("p",null,"when a valid operation is performed between an ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"f32"),", the integer is automatically promoted:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let i = ti.i32(4.2) // i32\nlet f = ti.f32(42)  // f32\nlet f2 = f + i      // f32\n")),(0,i.kt)("p",null,"Due to Javascript's lack of type annotations, kernel argument types in ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js")," are specified via an extra argument to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.kernel()")," call. The following example shows how to pass an ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"f32")," to a kernel, which returns their sum:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let k = ti.kernel(\n    { i: ti.i32, f: ti.f32 },\n    (i, f) => {\n        return i + f\n    }\n)\nconsole.log(await k(1, 2.5)) // prints 3.5\n")),(0,i.kt)("p",null,"If you don't specify the arguments, then ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js")," will assume they are ",(0,i.kt)("inlineCode",{parentName:"p"},"f32"),"s by default:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let k = ti.kernel(\n    (f1, f2) => {\n        return f1 + f2\n    }\n)\nconsole.log(await k(1.5, 2.5)) // prints 4.0\n")),(0,i.kt)("h2",{id:"vectors"},"Vectors"),(0,i.kt)("p",null,"Vectors are fixed-size tuples of primitives. In ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js"),", tuples are declared via the Javascript array notation ",(0,i.kt)("inlineCode",{parentName:"p"},"[...]"),". For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let vi = [0, 1, 2]\nlet vf = [0.0, 1.0, 2.0, 3.0]\n")),(0,i.kt)("p",null,"Vectors of the same type can have arithmetic operations among each other, where arithmetics are applied component wise. For example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let v = [1.0, 2.0] + [3.0, 4.0] // v = [4.0, 6.0]\n")),(0,i.kt)("p",null,"Vectors can also have arithmetic operations with scalars, where the scalar is broadcasted:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let v = [1.0, 2.0] * 2.0 // v = [2.0, 4.0]\n")),(0,i.kt)("p",null,"Beyond arithmetics, ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js")," contains many built-in mathematical operations which you can make use of. These are listed ",(0,i.kt)("a",{parentName:"p",href:"https://taichi-js.com/docs/docs/basics/builtin-functions"},"here"),"."),(0,i.kt)("h2",{id:"matrices"},"Matrices"),(0,i.kt)("h2",{id:"structs"},"Structs"))}m.isMDXComponent=!0}}]);