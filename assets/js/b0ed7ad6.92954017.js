"use strict";(self.webpackChunktaichi_js_com=self.webpackChunktaichi_js_com||[]).push([[9191],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),u=i,f=d["".concat(s,".").concat(u)]||d[u]||m[u]||r;return n?o.createElement(f,a(a({ref:t},p),{},{components:n})):o.createElement(f,a({ref:t},p))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,a=new Array(r);a[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:i,a[1]=l;for(var c=2;c<r;c++)a[c]=n[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1305:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var o=n(7462),i=(n(7294),n(3905));const r={sidebar_position:4,title:"Compile-Time Control Flow"},a=void 0,l={unversionedId:"docs/advanced/compile-time-control-flow",id:"docs/advanced/compile-time-control-flow",title:"Compile-Time Control Flow",description:"In taichi.js, you can write loops that are unrolled, or branches that are resolved at compile-time. Here's how and why.",source:"@site/docs/docs/2-advanced/4-compile-time-control-flow.md",sourceDirName:"docs/2-advanced",slug:"/docs/advanced/compile-time-control-flow",permalink:"/docs/docs/advanced/compile-time-control-flow",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/docs/2-advanced/4-compile-time-control-flow.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Compile-Time Control Flow"},sidebar:"tutorialSidebar",previous:{title:"Templates",permalink:"/docs/docs/advanced/templates"},next:{title:"Class Kernels",permalink:"/docs/docs/advanced/class-kernels"}},s={},c=[{value:"Loop-Unrolling",id:"loop-unrolling",level:2},{value:"Compile-Time Branch Resolution",id:"compile-time-branch-resolution",level:2}],p={toc:c},d="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js"),", you can write loops that are unrolled, or branches that are resolved at compile-time. Here's how and why."),(0,i.kt)("h2",{id:"loop-unrolling"},"Loop-Unrolling"),(0,i.kt)("p",null,"Loop-unrolling is the process of replacing fixed-range loops with repeated instances of the loop body for each possible loop index. In ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js"),", there are mainly two reason you would want to do this:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"(Possibly) Improved performance. Loop-unrolling removes the loop condition checks and ",(0,i.kt)("inlineCode",{parentName:"li"},"goto")," instructions. As a result, at runtime, a normal loop would execute more instructions than its unrolled version. However, this improved runtime performance comes at the cost of increased compile time, since the code in the loop body is repeated. "),(0,i.kt)("li",{parentName:"ol"},"Working around lack of dynamic-indexing in ",(0,i.kt)("inlineCode",{parentName:"li"},"taichi.js"),". As ",(0,i.kt)("a",{parentName:"li",href:"https://taichi-js.com/docs/docs/basics/type-system#vectors"},"previously mentioned"),", indices used to access vectors/lists/tuples must be compile-time constant expressions. For this reason, if you wish to use a loop index variable to index a vector, the compiler will complain. On the other hand, loop indices of unrolled loops are considered compile-time constant, so they can be used to access vectors just fine.")),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js"),", if you have a loop with a fixed range, you can force it to be unrolled by wrapping the ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.range(..)")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.ndrange(..)")," with a ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.Static()")," call. For example, consider the following kernel, which computes the sum of every element in a field of 4D vectors:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let f = ti.field(ti.types.vector(ti.i32, 4), 1000)\nti.addToKernelScope({ f })\nlet k = ti.kernel(() => {\n    let sum = 0.0\n    for(let i of ti.range(1000)){\n        for(let j of ti.Static(ti.range(4))){\n            sum += f[i][j]\n        }\n    }\n    return sum\n})\nconsole.log(await k())\n")),(0,i.kt)("p",null,"The inner ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),"-loop is unrolled, because its range is wrapped with ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.Static(..)"),". This means that the compiler will transform the kernel to the following form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let k = ti.kernel(() => {\n    let sum = 0.0\n    for(let i of ti.range(1000)){\n        sum += f[i][0]\n        sum += f[i][1]\n        sum += f[i][2]\n        sum += f[i][3]\n    }\n    return sum\n})\n")),(0,i.kt)("p",null,"Here, ",(0,i.kt)("inlineCode",{parentName:"p"},"f[i]")," is a 4D vector, and we are accessing them using compile-time-constant indices, so the compiler is happy. If, on the other hand, we don't include the ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.Static"),", then the following error will be thrown:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Error: Indices of vectors/matrices must be a compile-time constant\nat:\nsum += f[i][j];\n")),(0,i.kt)("h2",{id:"compile-time-branch-resolution"},"Compile-Time Branch Resolution"),(0,i.kt)("p",null,"If you have an ",(0,i.kt)("inlineCode",{parentName:"p"},"if-else")," branch whose condition can be determined at compile time, you can wrap your ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," condition with ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.Static()"),", which will ask the compiler to directly compile the branch that it knows will be taken, and completely ignore the other branch. This can be useful if you want your logic to depend on certain properties of a ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.template()")," argument. For example, the following kernel can be used to add 1 to every element of a field, and it works for both 1D and 2D fields:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let addOne = ti.kernel(\n    {f: ti.template()},\n    (f) => {\n        if(ti.Static(f.dimensions.length == 1)){\n            for(let i of ti.range(f.dimensions[0])){\n                f[i] += 1\n            }\n        }\n        else{\n            for(let I of ti.ndrange(f.dimensions[0], f.dimensions[1])){\n                f[I] += 1\n            }\n        }\n    }\n)\n")),(0,i.kt)("p",null,"If this kernel is invoked with an ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," that is a 1D field, then the branch resolution would transform the kernel to the following form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let addOne = ti.kernel(\n    () => {\n        for(let i of ti.range(f.dimensions[0])){\n            f[i] += 1\n        }\n    }\n)\n")),(0,i.kt)("p",null,"Similarly, if the ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," is a 2D field, then the compiled kernel would look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let addOne = ti.kernel(\n    () => {\n        for(let I of ti.ndrange(f.dimensions[0], f.dimensions[1])){\n            f[I] += 1\n        }\n    }\n)\n")),(0,i.kt)("p",null,"If the branch is not resolved by ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.Static()"),", then the code for ",(0,i.kt)("em",{parentName:"p"},"both")," 1D and 2D fields will exist simultaneously in two branches. This means that an error will always be thrown regardless of the dimensionality of the argument:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Error: field access dimension mismatch, received 1 components, but expecting 2 components\nat:\nf[i] += 1;\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Error: field access dimension mismatch, received 2 components, but expecting 1 components\nat:\nf[i] += 1;\n")))}m.isMDXComponent=!0}}]);