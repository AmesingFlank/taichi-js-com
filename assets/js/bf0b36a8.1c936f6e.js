"use strict";(self.webpackChunktaichi_js_com=self.webpackChunktaichi_js_com||[]).push([[3264],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>f});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=c(n),d=i,f=p["".concat(s,".").concat(d)]||p[d]||u[d]||o;return n?a.createElement(f,r(r({ref:t},m),{},{components:n})):a.createElement(f,r({ref:t},m))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:1,title:"Atomics"},r=void 0,l={unversionedId:"docs/advanced/atomics",id:"docs/advanced/atomics",title:"Atomics",description:"In taichi.js kernels, top-level for-loops are parallelized by the compiler. As a result, kernel code are subject to many of the common pitfalls in parallel programming. Consider this kernel which attempts to sum from 1 to 100:",source:"@site/docs/docs/2-advanced/1-atomics.md",sourceDirName:"docs/2-advanced",slug:"/docs/advanced/atomics",permalink:"/docs/docs/advanced/atomics",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/docs/2-advanced/1-atomics.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Atomics"},sidebar:"tutorialSidebar",previous:{title:"Kernel-Scope Code Semantics",permalink:"/docs/docs/basics/kernel-scope-code-semantics"},next:{title:"Functions and Lambdas",permalink:"/docs/docs/advanced/functions-and-lambdas"}},s={},c=[{value:"Syntactic Sugar",id:"syntactic-sugar",level:2},{value:"Atomics on Field Elements",id:"atomics-on-field-elements",level:2}],m={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js")," kernels, top-level ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),"-loops are parallelized by the compiler. As a result, kernel code are subject to many of the common pitfalls in parallel programming. Consider this kernel which attempts to sum from 1 to 100:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let sum100_buggy = ti.kernel(() => {\n    let sum = 0\n    for (let i of ti.range(100)){\n        sum = sum + (i + 1)\n    }\n    return sum\n})\nconsole.log(await sum100_buggy())\n")),(0,i.kt)("p",null,"If this summation logic do not live in a ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.kernel"),", then it is perfectly valid. However, due to parallelization, there are 100 GPU threads trying to to read from and write to the variable ",(0,i.kt)("inlineCode",{parentName:"p"},"sum"),' at the same time. This is known as a "race condition". There is no guarantee of what are values received by each of the threads, and the behavior of this kernel is essentially undefined.'),(0,i.kt)("p",null,"It's not always an easy task to figure out how to make kernel code free from race conditions. However, one tool that proves handy in many situation is atomics. And atomic operation is one which can be safely applied in parallel, and the hardware will take care of serializing the operation an ensuring its correctness. In our summation example, we may use an ",(0,i.kt)("inlineCode",{parentName:"p"},"atomicAdd"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let sum100 = ti.kernel(() => {\n    let sum = 0\n    for (let i of ti.range(100)){\n        ti.atomicAdd(sum, i + 1)\n    }\n    return sum\n})\nconsole.log(await sum100()) // 5050\n")),(0,i.kt)("p",null,"This is the full list of atomic operations available in ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ti.atomicAdd(destination, value)"),"  "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ti.atomicSub(destination, value)"),"  "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ti.atomicMax(destination, value)")," "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ti.atomicMin(destination, value)")," "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ti.atomicAnd(destination, value)"),"  "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ti.atomicOr(destination, value)"),"  "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ti.atomicXor(destination, value)"))),(0,i.kt)("h2",{id:"syntactic-sugar"},"Syntactic Sugar"),(0,i.kt)("p",null,"Instead of writing out ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.atomicAdd(destination, value)")," which is a bit clunky, ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js")," allows you to use the self-addition notation to express atomic semantics. That is, you can also write ",(0,i.kt)("inlineCode",{parentName:"p"},"destination += value"),". Using this syntax, the previous ",(0,i.kt)("inlineCode",{parentName:"p"},"sum100")," kernel can be written like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let sum100 = ti.kernel(() => {\n    let sum = 0\n    for (let i of ti.range(100)){\n        sum += i + 1\n    }\n    return sum\n})\nconsole.log(await sum100()) // 5050\n")),(0,i.kt)("p",null,"Similarly, you can also use "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-=")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"atomicSub")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&=")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"atomicAnd")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"|=")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"atomicOr")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"^=")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"atomicXor"))),(0,i.kt)("h2",{id:"atomics-on-field-elements"},"Atomics on Field Elements"),(0,i.kt)("p",null,"In the previous example, the atomic operation is applied to a global temporary variable. You can also use atomics on elements of a ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.field"),". Here is a example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let f = ti.field(ti.i32, 1)\nti.addToKernelScope({ f })\nlet sum100 = ti.kernel(() => {\n    f[0] = 0\n    for (let i of ti.range(100)){\n        f[0] += i + 1\n        // or ti.atomicAdd(f[0], i + 1)\n    }\n    return f[0]\n})\nconsole.log(await sum100()) // 5050\n")))}u.isMDXComponent=!0}}]);