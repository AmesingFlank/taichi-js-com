"use strict";(self.webpackChunktaichi_js_com=self.webpackChunktaichi_js_com||[]).push([[3972],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,f=d["".concat(s,".").concat(u)]||d[u]||m[u]||o;return n?i.createElement(f,a(a({ref:t},c),{},{components:n})):i.createElement(f,a({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,a=new Array(o);a[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,a[1]=l;for(var p=2;p<o;p++)a[p]=n[p];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2916:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var i=n(7462),r=(n(7294),n(3905));const o={sidebar_position:1,title:"Using taichi.js with Minifiers"},a=void 0,l={unversionedId:"docs/production/minifier",id:"docs/production/minifier",title:"Using taichi.js with Minifiers",description:"The Problem",source:"@site/docs/docs/4-production/1-minifier.md",sourceDirName:"docs/4-production",slug:"/docs/production/minifier",permalink:"/docs/docs/production/minifier",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/docs/4-production/1-minifier.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Using taichi.js with Minifiers"},sidebar:"tutorialSidebar",previous:{title:"GLTF",permalink:"/docs/docs/rendering/GLTF"},next:{title:"Using taichi.js with Typescript",permalink:"/docs/docs/production/typescript"}},s={},p=[{value:"The Problem",id:"the-problem",level:2},{value:"Mitigation",id:"mitigation",level:2},{value:"Rollup",id:"rollup",level:2}],c={toc:p},d="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"the-problem"},"The Problem"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js")," is a compiler. It takes Javascript code in your program and compiles them into WebGPU code. Under the hood, this is achieved by calling the ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString"},(0,r.kt)("inlineCode",{parentName:"a"},".toString()"))," on the methods you pass to ",(0,r.kt)("inlineCode",{parentName:"p"},"ti.kernel(..)"),". However, in production environments, we often pass the Javascript code into some sort of minifier, which often changes the source code of the functions significantly. This could often lead to compilation errors thrown by the ",(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js")," compiler when your program is running in release mode. "),(0,r.kt)("p",null,"As an example, consider the following program"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let fieldWithLongName = ti.field(ti.i32, 1000)\nti.addToKernelScope({ fieldWithLongName })\nlet k = ti.kernel(() => {\n    for(let i of ti.range(1000)){\n        fieldWithLongName[i] += 1\n    }\n}) \n")),(0,r.kt)("p",null,"A Javascript minifier might decide to rename the ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldWithLongName")," variable because its name is too long. The minifier will likely apply a code transformation that turns the code into"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let f = ti.field(ti.i32, 1000)\nti.addToKernelScope({ fieldWithLongName: f })\nlet k = ti.kernel(() => {\n    for(let i of ti.range(1000)){\n        f[i] += 1\n    }\n}) \n")),(0,r.kt)("p",null,"Now, all of a sudden, ",(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js")," will start complaining that it does not recognize the variable ",(0,r.kt)("inlineCode",{parentName:"p"},"f"),". This is because the transformed code still adds a variable named ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldWithLongName")," into the kernel scope, but the variable name within the kernel has already been modified."),(0,r.kt)("p",null,"This is only one example of how minifiers can mess-up the programming model of ",(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js"),". In general, minifiers and other code transformation tools may apply code transformations based on their own assumptions of the semantics of your code, and these assumptions often fail when ",(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js")," is involved. "),(0,r.kt)("h2",{id:"mitigation"},"Mitigation"),(0,r.kt)("p",null,"The ultimate mitigation, which is almost guaranteed to work, is to pass a string directly. ",(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js")," allows you to write this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let fieldWithLongName = ti.field(ti.i32, 1000)\nti.addToKernelScope({ fieldWithLongName })\nlet k = ti.kernel(\n    `\n    () => {\n        for(let i of ti.range(1000)){\n            fieldWithLongName[i] += 1\n        }\n    }\n    `\n) \n")),(0,r.kt)("p",null,"Since you are now passing a string to ",(0,r.kt)("inlineCode",{parentName:"p"},"ti.kernel()"),", no minifiers will dare modify it in any way."),(0,r.kt)("h2",{id:"rollup"},"Rollup"),(0,r.kt)("p",null,"If you use ",(0,r.kt)("a",{parentName:"p",href:"https://rollupjs.org/"},"rollup")," to bundle your project, there is a ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/rollup-plugin-taichi"},(0,r.kt)("inlineCode",{parentName:"a"},"rollup-plugin-taichi"))," which automatically turns every argument in ",(0,r.kt)("inlineCode",{parentName:"p"},"ti.kernel()")," into a string. You can enable it by putting this into your ",(0,r.kt)("inlineCode",{parentName:"p"},"rollup.config.js"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'...\nimport taichi from "rollup-plugin-taichi"\n\nexport default {\n  ...\n  plugins: [\n    taichi(),\n  ]\n};\n')),(0,r.kt)("p",null,"This will make sure all the kernels you write are free from the tempering of minifiers."))}m.isMDXComponent=!0}}]);