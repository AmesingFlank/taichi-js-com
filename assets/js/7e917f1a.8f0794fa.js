"use strict";(self.webpackChunktaichi_js_com=self.webpackChunktaichi_js_com||[]).push([[7613],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),f=r,u=m["".concat(s,".").concat(f)]||m[f]||d[f]||i;return n?a.createElement(u,o(o({ref:t},c),{},{components:n})):a.createElement(u,o({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},7545:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:3,title:"Templates"},o=void 0,l={unversionedId:"docs/advanced/templates",id:"docs/advanced/templates",title:"Templates",description:"In the doc page for fields, we briefly mentioned that ti.template() arguments can be used to pass fields into kernels as arguments. In this page, we will discuss exactly what this means, and what you can and cannot do with template arguments.",source:"@site/docs/docs/2-advanced/3-templates.md",sourceDirName:"docs/2-advanced",slug:"/docs/advanced/templates",permalink:"/docs/docs/advanced/templates",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/docs/2-advanced/3-templates.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Templates"},sidebar:"tutorialSidebar",previous:{title:"Functions and Lambdas",permalink:"/docs/docs/advanced/functions-and-lambdas"},next:{title:"Compile-Time Control Flow",permalink:"/docs/docs/advanced/compile-time-control-flow"}},s={},p=[],c={toc:p},m="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In the doc page for ",(0,r.kt)("a",{parentName:"p",href:"https://taichi-js.com/docs/docs/basics/fields#fields-as-template-argument-to-kernels"},"fields"),", we briefly mentioned that ",(0,r.kt)("inlineCode",{parentName:"p"},"ti.template()")," arguments can be used to pass fields into kernels as arguments. In this page, we will discuss exactly what this means, and what you can and cannot do with template arguments."),(0,r.kt)("p",null," Similar to template arguments in C++ functions, template arguments in a ",(0,r.kt)("inlineCode",{parentName:"p"},"taichi.js")," kernel are parameters that affect the code of the function themselves. More specifically, given a function ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," with a template argument ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", every time ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," is invoked with a different ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", a new version of the function itself is generated, where occurances of ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," within the function body are replaced with the hard-coded value of ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," in this invocation. For example, consider the following kernel"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let incrementAll = ti.kernel(\n    {f: ti.template()},\n    (f) => {\n        for(i of ti.range(f.dimensions[0])){\n            f[i] = f[i] + 1\n        }\n    }\n)\n")),(0,r.kt)("p",null,"Assuming you have two fields ",(0,r.kt)("inlineCode",{parentName:"p"},"f1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"f2"),". Then, upon calling ",(0,r.kt)("inlineCode",{parentName:"p"},"incrementAll(f1)"),", the compiler will create the following kernel on-the-fly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"ti.kernel(\n    () => {\n        for(i of ti.range(f1.dimensions[0])){\n            f1[i] = f1[i] + 1\n        }\n    }\n)\n")),(0,r.kt)("p",null,"In other workds, calling ",(0,r.kt)("inlineCode",{parentName:"p"},"incrementAll(f1)")," will generate a kernel which is hard-coded to operate only on ",(0,r.kt)("inlineCode",{parentName:"p"},"f1"),". And of course, calling ",(0,r.kt)("inlineCode",{parentName:"p"},"incrementAll(f1)")," will generate a kernel which only operates on ",(0,r.kt)("inlineCode",{parentName:"p"},"f2"),". Notice that these are two completely different kernels. So even though it looks like you are calling a single kernel with two different arguments, you will actually pay the cost of compiling two separate kernels. "),(0,r.kt)("p",null,"Even though the most common use-case for template arguments is to pass fields to a ",(0,r.kt)("inlineCode",{parentName:"p"},"ti.kernel"),", you can actually pass almost anything. One especialy interesting type of object you can pass is lambdas:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let applyAll = ti.kernel(\n    { f: ti.template(), operation: ti.template() },\n    (f, operation) => {\n        for (let i of ti.range(f.dimensions[0])) {\n            f[i] = operation(f[i]);\n        }\n    }\n);\nlet increment = (x) => x + 1;\nlet f = ti.field(ti.i32, 1000);\nawait applyAll(f, increment);\n")),(0,r.kt)("p",null,"Here, the we pass the ",(0,r.kt)("inlineCode",{parentName:"p"},"increment")," lambda to the ",(0,r.kt)("inlineCode",{parentName:"p"},"operation")," template argument. This will essentially trigger the following kernel to be genrated and called:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"ti.kernel(\n    () => {\n        for (let i of ti.range(f.dimensions[0])) {\n            f[i] = ((x) => x + 1)(f[i]);\n        }\n    }\n);\n")),(0,r.kt)("p",null,"The fact that you can pass almost anything as template arguments makes ",(0,r.kt)("inlineCode",{parentName:"p"},"ti.template()")," an incredibly flexible tool. However, be mindful that everytime you provide a new set of template arguments, your entire kernel will be re-compiled. So if you are frequently calling the kernel with new arguments, your program may end up being very slow, as it spends a lot of time creating and compiling new kernels."))}d.isMDXComponent=!0}}]);