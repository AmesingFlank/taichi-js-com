"use strict";(self.webpackChunktaichi_js_com=self.webpackChunktaichi_js_com||[]).push([[164],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=l(n),u=i,f=d["".concat(c,".").concat(u)]||d[u]||m[u]||a;return n?r.createElement(f,s(s({ref:t},p),{},{components:n})):r.createElement(f,s({ref:t},p))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,s=new Array(a);s[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[d]="string"==typeof e?e:i,s[1]=o;for(var l=2;l<a;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6677:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var r=n(7462),i=(n(7294),n(3905));const a={sidebar_position:3,title:"Type System"},s=void 0,o={unversionedId:"docs/basics/type-system",id:"docs/basics/type-system",title:"Type System",description:'In order for it to be compiled into WebGPU shaders, the Javascript function passed into ti.kernel() needs to obey certain rules that are not common to Javascript code. Most importantly, in normal Javascript-scope code, types of variables are not fixed and may change at runtime. This is different from kernel-scope code, where variables are "statically-typed". This means that types are fixed and determined at compile-time. When writing kernel code, it\'s useful to have a mental model of the type system in place, which this document will describe.',source:"@site/docs/docs/1-basics/3-type-system.md",sourceDirName:"docs/1-basics",slug:"/docs/basics/type-system",permalink:"/docs/docs/basics/type-system",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/docs/1-basics/3-type-system.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Type System"},sidebar:"tutorialSidebar",previous:{title:"Kernels",permalink:"/docs/docs/basics/kernels"},next:{title:"Feilds",permalink:"/docs/docs/basics/fields"}},c={},l=[{value:"Primitives",id:"primitives",level:2},{value:"Vectors",id:"vectors",level:2},{value:"Matrices",id:"matrices",level:2},{value:"Structs",id:"structs",level:2}],p={toc:l},d="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In order for it to be compiled into WebGPU shaders, the Javascript function passed into ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.kernel()"),' needs to obey certain rules that are not common to Javascript code. Most importantly, in normal Javascript-scope code, types of variables are not fixed and may change at runtime. This is different from kernel-scope code, where variables are "statically-typed". This means that types are fixed and determined at compile-time. When writing kernel code, it\'s useful to have a mental model of the type system in place, which this document will describe. '),(0,i.kt)("p",null,'We will begin with four of the most simple and commonly used data types: primitives, vectors, matrices, and structs. We will discuss how to declare variables of these types, and common operations on them. We will also show how to declare these types as arguments to kernels. Beyond these simple types, "variables" in kernels can also refer to data containers (i.e. ',(0,i.kt)("a",{parentName:"p",href:"https://taichi-js.com/docs/docs/basics/fields"},"fields")," and ",(0,i.kt)("a",{parentName:"p",href:"https://taichi-js.com/docs/docs/rendering/textures"},"textures"),") or ",(0,i.kt)("a",{parentName:"p",href:"https://taichi-js.com/docs/docs/advanced/functions-and-lambdas"},"lambdas/functions"),", which will be discussed in separate doc pages. "),(0,i.kt)("h2",{id:"primitives"},"Primitives"),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"taichi.js"),", there are only two primitive types at the moment: ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"f32"),". The compiler determines the type of a variable depending on the expression of its initializer:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// kernel scope\nlet i = 1   // i32\nlet f = 1.0 // f32 \n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"i32")," values can be casted to ",(0,i.kt)("inlineCode",{parentName:"p"},"f32")," via ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.f32(..)"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"f32")," values can be casted to ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," via ",(0,i.kt)("inlineCode",{parentName:"p"},"ti.i32(..)"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let i = ti.i32(4.2) // i32\nlet f = ti.f32(42)  // f32\n")),(0,i.kt)("p",null,"when a valid operation is performed between an ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"f32"),", the integer is automatically promoted:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let i = ti.i32(4.2) // i32\nlet f = ti.f32(42)  // f32\nlet f2 = f + i      // f32\n")),(0,i.kt)("h2",{id:"vectors"},"Vectors"),(0,i.kt)("h2",{id:"matrices"},"Matrices"),(0,i.kt)("h2",{id:"structs"},"Structs"),(0,i.kt)("h2",{id:""}))}m.isMDXComponent=!0}}]);