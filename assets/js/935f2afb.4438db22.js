"use strict";(self.webpackChunktaichi_js_com=self.webpackChunktaichi_js_com||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"category","label":"Articles","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Painless WebGPU Programming","href":"/docs/articles/painless-webgpu-programming","docId":"articles/painless-webgpu-programming"}]},{"type":"category","label":"Documentation","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"Basics","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Getting Started","href":"/docs/docs/basics/getting-started","docId":"docs/basics/getting-started"},{"type":"link","label":"Kernels","href":"/docs/docs/basics/kernels","docId":"docs/basics/kernels"},{"type":"link","label":"Type System","href":"/docs/docs/basics/type-system","docId":"docs/basics/type-system"},{"type":"link","label":"Built-in Functions","href":"/docs/docs/basics/builtin-functions","docId":"docs/basics/builtin-functions"}]},{"type":"category","label":"Advanced Programming","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Class Kernels","href":"/docs/docs/advanced/class-kernels","docId":"docs/advanced/class-kernels"},{"type":"link","label":"Functions and Lambdas","href":"/docs/docs/advanced/functions-and-lambdas","docId":"docs/advanced/functions-and-lambdas"},{"type":"link","label":"Atomics","href":"/docs/docs/advanced/atomics","docId":"docs/advanced/atomics"},{"type":"link","label":"Compile-time Control Flow","href":"/docs/docs/advanced/compile-time-control-flow","docId":"docs/advanced/compile-time-control-flow"},{"type":"link","label":"Templates","href":"/docs/docs/advanced/templates","docId":"docs/advanced/templates"}]},{"type":"category","label":"Rendering","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Render Pipelines","href":"/docs/docs/rendering/render-pipelines","docId":"docs/rendering/render-pipelines"},{"type":"link","label":"Textures","href":"/docs/docs/rendering/textures","docId":"docs/rendering/textures"}]},{"type":"category","label":"Working in Production","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Working with Rollup","href":"/docs/docs/production/rollup","docId":"docs/production/rollup"},{"type":"link","label":"Working with Typescript","href":"/docs/docs/production/typescript","docId":"docs/production/typescript"}]}]}]},"docs":{"articles/painless-webgpu-programming":{"id":"articles/painless-webgpu-programming","title":"Painless WebGPU Programming","description":"As a computer graphics and programming languages geek, I am delighted to have found myself working on several GPU compilers in the past 2 years. This began in 2021 when I started to contribute to taichi, a python library that compiles python functions into GPU kernels in CUDA, Metal, or Vulkan. Later on, I joined Meta and started worked on SparkSL, which is the shader language that powers cross-platform GPU programming for AR effects in Instagram and Facebook. Aside from personal pleasure, I have always believed, or at least hoped, that these frameworks are actually quite useful -- they make GPU programming more accessible to non-experts, empowering people to create fasnicating graphics contents without having to master complex GPU concepts.","sidebar":"tutorialSidebar"},"docs/advanced/atomics":{"id":"docs/advanced/atomics","title":"Atomics","description":"","sidebar":"tutorialSidebar"},"docs/advanced/class-kernels":{"id":"docs/advanced/class-kernels","title":"Class Kernels","description":"","sidebar":"tutorialSidebar"},"docs/advanced/compile-time-control-flow":{"id":"docs/advanced/compile-time-control-flow","title":"Compile-time Control Flow","description":"","sidebar":"tutorialSidebar"},"docs/advanced/functions-and-lambdas":{"id":"docs/advanced/functions-and-lambdas","title":"Functions and Lambdas","description":"","sidebar":"tutorialSidebar"},"docs/advanced/templates":{"id":"docs/advanced/templates","title":"Templates","description":"","sidebar":"tutorialSidebar"},"docs/basics/builtin-functions":{"id":"docs/basics/builtin-functions","title":"Built-in Functions","description":"","sidebar":"tutorialSidebar"},"docs/basics/getting-started":{"id":"docs/basics/getting-started","title":"Getting Started","description":"taichi.js is a Javascript framework which translates JS code into WebGPU compute and/or render pipelines. With taichi.js, the programmer can write WebGPU programs without having to deal with WebGPU\'s API or shading language. It offers a way to rapidly prototype WebGPU programs, for both parallel computation and rendering purposes. It is inspired by and named after the taichi Python library, from which it also inherits many API concepts and design principles.","sidebar":"tutorialSidebar"},"docs/basics/kernels":{"id":"docs/basics/kernels","title":"Kernels","description":"In taichi.js, Javascript functions that are compiled into WebGPU shaders are called \\"kernels\\". Kernels are created by passing a lambda function to ti.kernel(). For example:","sidebar":"tutorialSidebar"},"docs/basics/type-system":{"id":"docs/basics/type-system","title":"Type System","description":"","sidebar":"tutorialSidebar"},"docs/production/rollup":{"id":"docs/production/rollup","title":"Working with Rollup","description":"","sidebar":"tutorialSidebar"},"docs/production/typescript":{"id":"docs/production/typescript","title":"Working with Typescript","description":"","sidebar":"tutorialSidebar"},"docs/rendering/render-pipelines":{"id":"docs/rendering/render-pipelines","title":"Render Pipelines","description":"","sidebar":"tutorialSidebar"},"docs/rendering/textures":{"id":"docs/rendering/textures","title":"Textures","description":"","sidebar":"tutorialSidebar"}}}')}}]);