"use strict";(self.webpackChunktaichi_js_com=self.webpackChunktaichi_js_com||[]).push([[222],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},l=Object.keys(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=i.createContext({}),c=function(e){var t=i.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return i.createElement(o.Provider,{value:t},e.children)},p="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=a,u=p["".concat(o,".").concat(m)]||p[m]||f[m]||l;return n?i.createElement(u,r(r({ref:t},d),{},{components:n})):i.createElement(u,r({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,r=new Array(l);r[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[p]="string"==typeof e?e:a,r[1]=s;for(var c=2;c<l;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2572:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>f,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const l={sidebar_position:5,title:"Fields"},r=void 0,s={unversionedId:"docs/basics/fields",id:"docs/basics/fields",title:"Fields",description:"Fields are the most basic type of data containers in taichi.js. Fields are n-dimensional arrays, where each element of the array can be either a primitive, a vector, a matrix, or a struct. Fields always live in GPU memory.",source:"@site/docs/docs/1-basics/4-fields.md",sourceDirName:"docs/1-basics",slug:"/docs/basics/fields",permalink:"/docs/docs/basics/fields",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/docs/1-basics/4-fields.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Fields"},sidebar:"tutorialSidebar",previous:{title:"Type System",permalink:"/docs/docs/basics/type-system"},next:{title:"Built-in Functions",permalink:"/docs/docs/basics/builtin-functions"}},o={},c=[{value:"Declarations",id:"declarations",level:2},{value:"Accessing Fields in Kernels",id:"accessing-fields-in-kernels",level:2},{value:"Accessing Fields in Javascript Scope",id:"accessing-fields-in-javascript-scope",level:2},{value:"Accessing Metadata",id:"accessing-metadata",level:2},{value:"Fields as Template Argument to Kernels",id:"fields-as-template-argument-to-kernels",level:2}],d={toc:c},p="wrapper";function f(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Fields are the most basic type of data containers in ",(0,a.kt)("inlineCode",{parentName:"p"},"taichi.js"),". Fields are n-dimensional arrays, where each element of the array can be either a primitive, a vector, a matrix, or a struct. Fields always live in GPU memory."),(0,a.kt)("h2",{id:"declarations"},"Declarations"),(0,a.kt)("p",null,"To declare a field, use the function ",(0,a.kt)("inlineCode",{parentName:"p"},"ti.field( <element type>, <dimensions> )"),", here are a few examples:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// 1D field of 1000 floats\nlet scalarField1D = ti.field(ti.f32, 1000);\n\n// 2D field of 1000x1000 floats\nlet scalarField2D = ti.field(ti.f32, [1000, 1000]);\n\n// 2D field of 1000x1000 3D float vectors\nlet vectorField = ti.field(ti.types.vector(ti.f32, 3), [1000, 1000]);\n\n// 1D field of 1000 2x2 float matrices\nlet matrixField = ti.field(ti.types.matrix(ti.f32, 2, 2), 1000);\n\n// 1D field of 1000 particles\nlet particleType = ti.types.struct({\n  pos: ti.types.vector(ti.f32, 3),\n  vel: ti.types.vector(ti.f32, 3),\n});\nlet particles = ti.field(particleType, 1000);\n")),(0,a.kt)("p",null,"For vector and matrix fields, there is a shorthand syntax for creating them without having to write ",(0,a.kt)("inlineCode",{parentName:"p"},"ti.types.vector/matrix"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// 2D field of 1000x1000 3D float vectors\nlet vectorField = ti.Vector.field(3, ti.f32, [1000, 1000]);\n\n// 1D field of 1000 2x2 float matrices\nlet matrixField = ti.Matrix.field(2, 2, ti.i32, 1000);\n")),(0,a.kt)("p",null,"When the field is first declared, it is 0-intialized, meaning that all the values in the field are initialized to 0."),(0,a.kt)("p",null,"Notice that fields must be declared in normal Javascript code. In kernel scope, you can read and write from fields in ",(0,a.kt)("inlineCode",{parentName:"p"},"taichi.js")," kernels, but you cannot create new ones."),(0,a.kt)("h2",{id:"accessing-fields-in-kernels"},"Accessing Fields in Kernels"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"taichi.js")," kernel code can access fields using the indexing syntax ",(0,a.kt)("inlineCode",{parentName:"p"},"field[index]"),". Let's see an example of this for 1D fields first. (Reminder: as previously explained in the ",(0,a.kt)("a",{parentName:"p",href:"https://taichi-js.com/docs/docs/basics/kernels"},"Kernels")," doc page, you need to call ",(0,a.kt)("inlineCode",{parentName:"p"},"ti.addToKernelScope({ ... })")," on each field you want to use in kernels)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"let scalarField = ti.field(ti.f32, 1000);\nlet vectorField = ti.field.vector(ti.types.vector(ti.f32, 3), 1000);\n\nti.addToKernelScope({ scalarField, vectorField });\n\nlet k = ti.kernel(() => {\n    scalarField[0] = 42.0;\n    let f = scalarField[0]; // 42.0\n\n    vectorField[0] = [1.0, 2.0, 3.0];\n    let v = vectorField[0]; // [1.0, 2.0, 3.0]\n    ...\n});\n")),(0,a.kt)("p",null,"For accessing 2D fields, you can pass-in a vector inside the square-brackets to access them:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"let scalarField = ti.field(ti.f32, [1000, 1000]);\nti.addToKernelScope({ scalarField });\n\nlet k = ti.kernel(() => {\n    scalarField[[123, 456]] = 42.0;\n    let f = scalarField[[123, 456]]; // 42.0\n    ...\n});\n")),(0,a.kt)("p",null,"A very common pattern in ",(0,a.kt)("inlineCode",{parentName:"p"},"taichi.js")," code is to process every element of a field in parallel. This can be done using a parallelized ",(0,a.kt)("inlineCode",{parentName:"p"},"for"),"-loop whose range is the same as the index of the field:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"let f1 = ti.field(ti.f32, 1000);\nlet f2 = ti.field(ti.f32, [1000, 1000]);\nti.addToKernelScope({ f1, f2 });\n\nlet increment = ti.kernel(() => {\n    for(let i of ti.range(1000)){\n        f1[i] = f1[i] + 1\n    }\n    for(let I of ti.ndrange(1000, 1000)){\n        f2[I] = f2[I] + 1\n    }\n})\n")),(0,a.kt)("h2",{id:"accessing-fields-in-javascript-scope"},"Accessing Fields in Javascript Scope"),(0,a.kt)("p",null,"You can also access fields from Javascript-code. Notice that this is a costly operation, as it requires copying data between the GPU and the CPU. Here's the API for reading/writing individual elements of fields:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"let scalarField = ti.field(ti.f32, [1000, 1000]);\n// writing\nawait scalarField.set([123, 456], 42.0)\n// reading\nconsole.log(await scalarField.get([123, 456])) // 42.0\n")),(0,a.kt)("p",null,"Beyond the ",(0,a.kt)("inlineCode",{parentName:"p"},"set")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"get")," methods for accessing inidividual elements, there is also an API for copying the entire field from GPU to Javascript:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"let scalarField = ti.field(ti.i32, 10);\n// writing\nawait scalarField.fromArray([0,1,2,3,4,5,6,7,8,9])\n// reading\nconsole.log(await scalarField.toArray()) //[0,1,2,3,4,5,6,7,8,9]\n")),(0,a.kt)("h2",{id:"accessing-metadata"},"Accessing Metadata"),(0,a.kt)("p",null,"If you have a ",(0,a.kt)("inlineCode",{parentName:"p"},"ti.field")," named ",(0,a.kt)("inlineCode",{parentName:"p"},"f"),", you can find its dimensions using ",(0,a.kt)("inlineCode",{parentName:"p"},"f.dimensions"),". This works in both Javascript-scope and kernel-scope:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"let scalarField2D = ti.field(ti.f32, [1000, 1000]);\nconsole.log(scalarField2D.dimensions) // [1000, 1000]\n\nti.addToKernelScope({ scalarField2D });\nlet k = ti.kernel(() => {\n    return scalarField2D.dimensions\n})\nconsole.log(await k())\n")),(0,a.kt)("h2",{id:"fields-as-template-argument-to-kernels"},"Fields as Template Argument to Kernels"),(0,a.kt)("p",null,"You can pass fields as argument to kernels by declaring a template argument:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"let scalarField = ti.field(ti.f32, [1000, 1000]);\nlet increment = ti.kernel(\n    { f: ti.template() },\n    (f) => {\n        for(let I of ti.ndrange(f.dimensions[0], f.dimensions[1])){\n            f[I] = f[I] + 1\n        }\n    }\n)\nawait increment(scalarField)\n")))}f.isMDXComponent=!0}}]);